# 스터디 1주차 스레드와 스케줄러

</br></br>

---

</br></br>

# 프로세스

- 프로세스는 기억장치에 저장되어 있는 프로그램이 메모리에 적재되어 CPU의 할당을 받을 수 있는 것을 말한다. 프로세스가 생긴다는 것은 **PCB가 커널 영역에(메모리) 생성된다는 것을 뜻한다**
- 프로세스는 함수의 매개변수, 복귀 주소와 로컬 변수과 같은 임시 자료를 갖는 프로세스 **스택**과, 전역 변수들을 수록하는 데이터 섹션을 포함한다
   - 프로세스는 크게 **코드 영역, 스택 영역, 데이터 영역**으로 나뉜다
   - 이때 **스택 영역은** 복귀 주소 = 되돌아갈 주소값(return 시 어디로 돌아갈지)를 쌓기위해, 그에 따른 로컬 변수 등을 저장하기 위해 위해 생성된다
   - 전역 변수들은 **데이터 영역**에 저장된다
- 프로세스는 프로세스 실행 중에 동적으로 할당되는 메모리인 **힙을 포함**한다
   - 일부 데이터는 프로그램이 실행되는 동안 할당되는데 대표적인 경우가 malloc() 함수다

</br>

### 프로세스 제어 블록 (Process Control Block, PCB)

- PCB는 특정 프로세스에 대한 중요한 정보를 저장하고 있는 운영체제의 자료구조이다
- 운영체제는 프로세스를 관리하기 위해 프로세스의 생성과 동시에 고유한 PCB를 생성한다
- 프로세스는 CPU를 할당받아 작업 처리하다가 프로세스 전환이 발생하면 진행하던 작업을 모두 PCB에 저장하고 CPU를 반환하다
- 다시 CPU를 할당받게 되면 PCB에 저장되어 있던 내용을 불러와 이전에 종료됐던 시점부터 다시 작업을 수행한다

</br>

**[PCB에 저장되는 정보]**

- **프로세스 식별자** (Process ID): 프로세스 식별번호
- **프로세스 상태**: new, ready, running, waiting, terminated 등의 상태를 저장
- **프로그램 카운터**: 프로세스가 다음에 실행할 명령어의 주소
- CPU 레지스터의 값
   - **데이터 레지스터의 값** (Data Register): 메모리 관리자가 레지스터에 직접 접근할 수 없기에 **메모리 관리자가 MBR에 저장한 값**을 **제어장치가 DR로** 읽어들어서 **CPU가 사용**한다
   - 주소 레지스터의 값 (Address Register): 데이터 또는 명령어가 저장된 메모리의 주소를 저장
   - 프로그램 카운터의 값 (Program Counter): 다음에 실행할 명령어의 위치를 저장
   - 명령어 레지스터의 값 (Instrunction Register): 현재 실행 중인 명령어 저장
   - **메모리 주소 레지스터의 값** (Memory Address Register): 메모리 관리자가 접근해야 할 메모리 주소 저장
   - **메모리 버퍼 레지스터의 값** (Memory Buffer Register): MAR에 저장한 주소가 있다면 메모리 관리자가 해당 주소에 접근해 데이터를 가져와 MBR에 임시로 저장한다
   - **프로그램 상태 레지스터의 값** (Program Status Register): 연산 결과를 저장
- CPU 스케줄링 정보
   - **프로세스의 우선 순위**
   - **포인터**: 프로세스 제어 블록을 연결하여 준비 상태나 대기 상태 큐를 구현할 때 포인터로 사용된다.
- 메모리 관리 정보
   - 프로세스가 메모리의 어디에 있는지 나타내는 메모리 위치 정보
   - **한계 레지스터 값** (현재 진행 중인 작업이 차지하고 메모리의 크기)**, 경계 레지스터 값** (현재 진행 중인 작업의 메모리 시작 주소)을 포함한다
- 입출력 상태 정보: 프로세스에 할당된 입출력 장치들과 열린 파일 목록
- 어카운팅 정보: 사용된 CPU시간, 시간제한(타이머), 계정 번호

</br>

**[고아 프로세스]**

- 부모 프로세스가 먼저 종료되어 돌아갈 곳이 없는 프로세스,
   - 그럼 아마 상위 프로세스가 입양함 (뇌피셜)

</br>

**[좀비 프로세스]**

- 자식 프로세스가 종료되었는데도 부모 프로세스가 뒤처리 하지 않는 상태

</br></br></br>

# 스레드

- **프로세스의 실행 단위**, CPU의 큐도 스레드 단위로 움직임.
- 한 프로세스 내에서 동작되는 여러 실행 흐름으로 프로세스 내의 주소 공간이나 자원을 공유
- **스레드는 PCB의 동적 영역을(프로그램 카운터, 레지스터, 스택, 힙 등) 독립적으로 가지고 정적 영역(PCB의 코드 영역, 데이터 영역)을 공유한다.**
   - 레지스터 집합
      - **데이터 레지스터의 값** (Data Register): 메모리 관리자가 레지스터에 직접 접근할 수 없기에 **메모리 관리자가 MBR에 저장한 값**을 **제어장치가 DR로** 읽어들어서 **CPU가 사용**한다
      - 주소 레지스터의 값 (Address Register): 데이터 또는 명령어가 저장된 메모리의 주소를 저장
      - 프로그램 카운터의 값 (Program Counter): 다음에 실행할 명령어의 위치를 저장
      - 명령어 레지스터의 값 (Instrunction Register): 현재 실행 중인 명령어 저장
      - **메모리 주소 레지스터의 값** (Memory Address Register): 메모리 관리자가 접근해야 할 메모리 주소 저장
      - **메모리 버퍼 레지스터의 값** (Memory Buffer Register): MAR에 저장한 주소가 있다면 메모리 관리자가 해당 주소에 접근해 데이터를 가져와 MBR에 임시로 저장한다
      - **프로그램 상태 레지스터의 값** (Program Status Register): 연산 결과를 저장
- **하나의 프로세스를 다수의 실행 단위(스레드)로 구분**하여 자원을 공유하고 자원의 생성과 관리의 중복성을 최소화 하여 수행 능력을 향상시키는 것을 **멀티 스레딩**이라고 한다
- 각각의 스레드는 독립적인 작업을 수행해야 하기 때문에 각자의 스택과 PC 레지스터 값을 갖고 있다

</br>

**[스택을 스레드마다 독립적으로 할당하는 이유]**

- 스택은 함수 호출 시 전달되는 인자, 되돌아갈 주소값, 함수내에서 선언하는 변수 등을 저장하기 위해 사용되는 메모리 공간이므로 **스택 메모리 공간이 독립적이라는 것은 독립적인 함수 호출이 가능하다는 것이다**
- 즉 독립적인 실행 흐름이 추가하기 위해 독립된 스택을 할당한다

</br>

**[ProgramCounter 레지스터를 스레드마다 독립적으로 할당하는 이유]**

- PC값은 스레드의 명령어의 어디까지 수행하였는지를 나타나게 된다
- 스레드는 CPU를 할당 받았다가 스케줄러에 의해 빼앗기는데 그렇기 때문에 명령어가 연속적으로 수행되지 못하고 **어느 부분까지 수행했는지 기억해야하기 때문에** PC 레지스터를 독립적으로 할당한다

</br>

**[싱글 스레드 방식]**

- 멀티 스레드의 반대
- 프로세스는 하나의 스레드를 기본으로 가진다

[스레드와 프로세스의 차이]

- 프로세스는 스레드를 포괄한다
- 통신에서 차이가 있음 → 더 공부

---

</br></br>

# 멀티스레드

</br>

## 멀티 스레딩의 장점

- 프로세스를 이용하여 처리하던 일을 스레드로 구현할 경우 메모리 공간과 시스템 자원 소모가 줄어들게 된다
   - 4개의 프로세스를 구동할 경우 4개의 PCB가 필요하지만 4개의 스레드로 구동하면 공유하는 정적 영역 만큼의 공간이 절약된다
- 스레드 간의 통신이 필요한 경우에도 별도의 자원을 이용하는 것이 아니라 전역 변수의 공간(데이터 영역) 또는 동적으로 할당된 공간이 Heap 영역을 이용하여 데이터를 주고 받을 수 있다
   - 여러가지 방법이 있는 것으로 알고 있음 직통 방식이 있고 mailbox 방식이 있는거로 알고 있는뎅 찾아보기
- 스레드의 context switch는 프로세스 context switch 와는 달리 캐시 메모리를 비울 필요가 없기 때문에 더 빠르다
   - 프로세스 컨텍스트 스위치
      1. 현재 실행 중인 프로세스의 상태 정보(프로세스 레지스터, 스택 포인터, 프로그램 카운터 등)를 해당 프로세스의 PCB(Process Control Block)에 저장
      2. 스케줄링 알고리즘에 따라 다음 실행할 프로세스를 선택
      3. 선택된 프로세스의 PCB에서 이전에 저장된 상태 정보를 읽어와 CPU 레지스터, 스택 포인터, 프로그램 카운터 등에 복원
   - 스레드 컨텍스트 스위치
      1. 현재 실행 중인 스레드의 상태 정보(스레드 레지스터, 스택 포인터, 프로그램 카운터 등)를 해당 스레드의 TCB(Thread Control Block)에 저장
      2. 스케줄링 알고리즘에 따라 다음 실행할 스레드를 선택
      3. 선택된 스레드의 TCB에서 이전에 저장된 상태 정보를 읽어와 CPU 레지스터, 스택 포인터, 프로그램 카운터 등에 복원
   - **스레드 컨텍스트 스위치는 프로세스의 주소 공간을 공유하기 때문에 상대적으로 빠름 또한 캐시 메모리에는 주로 최근에 사용한 데이터가 저장되는 스레드 간의 컨텍스트 스위치는 주소 공간 변경이 필요하지 않기 때문에 캐시 메모리를 비울 필요가 없어 더 빠르게 수행됨**

</br>

## 멀티 스레딩의 문제점

- 멀티 프로세스 기반으로 프로그래밍 할 때는 프로세스간 공유하는 자원이 없기 때문에 동일한 자원에 동시에 접근하는 일이 없지만 멀티 스레딩을 기반으로 프로그래밍할 때는 이 부분을 신경써야 한다
- 그렇기에 멀티스레딩 환경에서는 자원 공유의 문제가 있다고 할 수 있는데 동기화 문제를 해결하다보면 병목 현상이 발생하여 성능이 저하될 가능성이 높다. 과도한 락으로 인한 병목 현상을 줄여야 한다

</br>

## 멀티 스레드 vs 멀티 프로세스

- **멀티 스레드**는 멀티 프로세스보다 적은 메모리 공간을 차지하고 문맥 전환이 빠르다는 장점이 있지만 오류로 인해 하나의 프로세스가 종료되면 **전체 스레드가 종료될 수 있다는 점과 동기화 문제가 있다**
- 반면 **멀티 프로세스** 방식은 하나의 프로세스가 죽더라도 다른 프로세스에는 영향을 끼치지 않고 정상적으로 수행된다는 장점이 있지만 멀티 스레드보다 **많은 메모리 공간과 CPU 시간** (문맥 교환에 많은 시간이 소요됨)을 차지한다는 단점이 존재한다.
- 이 두 가지는 여러 작업을 수행한다는 점에서 같지만 적용해야하는 시스템에 따라 적합/부적합이 구분된다. 따라서 대상 시스템의 특징에 따라 적합한 동작 방식을 선택해 사용해야 한다

</br>

**[멀티 스레드를 활용한 프로그램 vs 멀티 프로세스를 활용한 프로그램]**

- 대부분의 사용자가 사용하는 프로그램은 멀티 스레드를 사용한다.
- 클라이언트 하나하나의 요청이 중요한 서버 프로그램의 경우 멀티 프로세스로 구현해야 할 것 같다. 한 명의 클라이언트의 스레드가 문제가 생겼다고 다른 모든 클라이언트의 요청이 끊기는건 위험하기 때문

---

</br></br>

# 스케줄러

*프로세스를 스케줄링 하기 위한 Queue에는 세가지 종류가 존재한다*

- Job Queue: 현재 시스템 내에 있는 모든 프로세스의 집합
- Ready Queue: 현재 메모리 내에 있으면서 CPU를 잡아서 실행되기를 기다리는 프로세스의 집합
- Device Queue: Device I/O 작업을 대기하고 있는 프로세스의 집합

각각의 **Queue에 프로세스들을 넣고 빼주는 스케줄러**에도 세 가지 종류가 존재한다

</br>

## 장기 스케줄러 (Long-term scheduler, job scheduler)

메모리는 한정되어 있는데 많은 프로세스가 한꺼번에 메모리로 올라오며 생성될 경우, 대용량 메모리(디스크)에 임시로 저장된다. 이 디스크 pool에 저장되어 있는 프로세스 중 어떤 프로세스에 메모리에 할당하여 ready queue에 보낼지 결정하는 역할을 한다

- 메모리와 디스크 사이의 스케줄링을 담당
- 프로세스에 메모리 및 각종 리소스를 할당
- degree of Multiprogramming 제어 (실행 중인 프로세스 수 제어)
- 프로세스의 상태 관리 (new → ready)

메모리에 프로그램이 너무 많이 올라가도 너무 적게 올라가도 성능이 좋지 않다. 당연하다. *time sharing system에서는 장기 스케줄러가 없다*. **요즘은 곧바로 메모리에 올라가 ready 상태가 된다**

</br>

## 단기 스케줄러 (Short-term scheduler or CPU scheduler)

- CPU와 메모리 사이의 스케줄링을 담당
- Ready Queue에 존재하는 프로세스 중 어떤 프로세스를 running 시킬지 결정
- 프로세스에 CPU를 할당 (scheduler dispatch)
- 프로세스의 상태 ready(준비) → running(실행)

</br>

## 중기 스케줄러 (Medium-term scheduler or Swapper)

- 여유 공간 마련을 위해 프로세스를 통째로 메모리에서 디스크로 쫓아냄 (swapping)
- 프로세스에게서 메모리를 뺏어감
- degree of Multiprogramming 제어 (실행 중인 프로세스 수 제어)
- 현 시스템에서 메모리에 너무 많은 프로그램이 동시에 올라가는 조절하는 스케줄러
- 프로세스의 상태 ready(준비) → suspended(대기)

</br>

**[Process state - suspended]**

외부적인 이유로 프로세스의 수행이 정지된 상태로 메모리에서 내려간 상태를 의미한다. 프로세스가 전부 디스크로 swap out된다. blocked 상태는 다른 I/O를 기다리는 상태이기 때문에 스스로 ready state로 돌아갈 수 있지만 이 상태는 외부적인 이유로 suspending 되었기 때문에 스스로 돌아갈 수 없다.

